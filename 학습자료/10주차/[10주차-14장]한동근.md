# 14장 컬렉션과 부가 기능

이 장에서 다룰 내용

1. 컬렉션 : 다양한 컬렉션의 특징을 설명한다.
2. 컨버터 : 엔티티의 데이터를 변환해서 DB에 저장한다.
3. 리스너 : 엔티티에서 발생한 이벤트를 처리한다.
4. 엔티티 그래프 : 엔티티를 조회할 때 연관된 엔티티를 선택해서 함께 조회한다.

# 14.1. 컬렉션

JPA는 자바에서 기본 제공하는 Collection, List, Set, Map을 지원한다.  

다음 경우에 이 컬렉션을 사용할 수 있다.

- @OneToMany, @ManyToMany를 사용해서 일대다나 다대다 엔티티 관계를 매핑할 때
- @ElementCollection을 사용해서 값 타입을 하나 이상 보관할 때

자바 컬렉션 인터페이스의 특징

- Collection : 자바가 제공하는 최상위 컬렉션. 중복 허용하고 순서 보장하지 않는다고 가정
- Set : 중복을 허용하지 않는 컬렉션. 순서 보장 X
- List : 순서가 있는 컬렉션. 순서를 보장하고 중복 허용
- Map : Key, Value 구조로 되어 있는 특수 컬렉션.

## 14.1.1. JPA와 컬렉션

하이버네이트는 엔티티를 영속 상태로 만들 때 컬렉션 필드를 하이버네이트에서 준비한 컬렉션으로 감싸서 사용한다.  
```java
@Entity
public class Team{
    
    @Id 
    private String id;
    
    @OneToMany
    @JoinColumn
    private Collection<Member> members = new ArrayList<Member>();
}
```
위 코드의 Team은 members 컬렉션을 필드로 가지고 있다.  

다음 코드로 Team을 영속 상태로 만들어보자.  

```java
Team team = new Team();

System.out.println("before persist = " + team.getMembers().getClass());
em.persist(parent);
System.out.println("after persist = " + team.getMembers().getClass());
```

출력 결과는 다음과 같다.  

```java
before persist = class java.util.ArrayList
after persist = class org.hibernate.collection.internal.PersistentBag
```

원래 ArrayList 타입이었던 컬렉션이 엔티티를 영속 상태로 만든 직후가 PersistentBag 타입으로 변경되었다.  

하이버네이트는 컬렉션의 효율적 관리를 위해 엔티티를 영속 상태로 만들 때 원본 컬렉션을 감싸고 있는 내장 컬렉션을
 생성해서 이 내장 컬렉션을 사용하도록 참조를 변경한다.  

하이버네이트는 이런 특징 때문에 컬렉션을 사용할 때 즉시 초기화해서 사용하는 것을 권장한다.  

| 컬렉션 인터페이스           | 내장 컬렉션         | 중복 허용 | 순서 보관 |
|---------------------|----------------|-------|-------|
| Collection, List    | PersistenceBag | O     | X     |
| Set                 | PersistenceSet | X     | X     |
| List + @OrderColumn | PersistentList | O     | O     |


## 14.1.2. Collection, List

중복을 허용하는 컬렉션이고 PersistentBag을 래퍼 컬렉션으로 사용한다.  

ArrayList로 초기화하면 된다.  

Collection, List는 중복을 허용한다고 가정하므로 객체를 추가하는 add() 메소드는 내부에서 어떤 비교도 하지 않고
 항상 true를 반환한다.  

같은 엔티티가 있는지 찾거나 할 때는 equals()메소드를 사용한다.  

`Collection, List는 엔티티 추가 시 중복 엔티티가 있는지 비교하지 않고 단순 저장만 하면 된다.`  
`따라서 엔티티를 추가해도 지연 로딩된 컬렉션을 초기화하지 않는다.`

## 14.1.3. Set

Set은 중복을 허용하지 않는 컬렉션이다. 하이버네이트는 PersistentSet을 컬렉션 래퍼로 사용한다.  

이 인터페이스는 HashSet으로 초기화하면 된다.  

HashSet은 중복 허용 하지 않으므로 add()메소드로 객체 추가시마다 equals()메소드로 같은 객체가 있는지 비교한다.  

HashSet은 해시 알고리즘을 사용하므로 hashcode()도 함께 사용해서 비교한다.  

`Set은 엔티티를 추가할 때 중복된 엔티티가 있는지 비교해야 한다.`  
`따라서 엔티티를 추가할 때 지연 로딩된 컬렉션을 초기화한다.`

## 14.1.4. List + @OrderColumn

실무에서 잘 사용하지 않는다. 패스

## 14.1.5. @OrderBy

DB의 ORDER BY 절을 사용해서 컬렉션을 정렬한다.  

@OrderBy는 모든 컬렉션에 사용할 수 있다. 

```java
@OneToMany(mappedBy = "team")
@OrderBy("username desc, id asc")
private Set<Member> members = new HashSet<Member>();
```
Team.members를 보면 @OrderBy를 적용했다.  

@OrderBy의 값으로 username, desc, id asc를 사용해서 Member의 username 필드로 내림차순 정렬, id로 오름차순 정렬했다.  

@OrderBy의 값은 JPQL의 order by절처럼 엔티티의 필드를 대상으로 한다.  

# 14.2. @Converter

컨버터를 사용하면 엔티티의 데이터를 변환해서 DB에 저장할 수 있다.  

회원의 VIP 여부를 자바의 boolean 타입을 사용하고 싶다고 하자.  

JPA를 사용하면 DB에 저장될 때 0 또는 1인 숫자로 저장된다.  

그런데 DB에 숫자 대신 문자 Y 또는 N 으로 저장하고 싶다면 컨버터를 사용하면 된다.  
